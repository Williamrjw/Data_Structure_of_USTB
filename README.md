# Data_Structure_of_USTB
a repository of work “数据结构”  
## 目录 content
- 第二章
- 第三章
  - [通话记录](#通话记录)
  - [狗头菌的魔法机](#狗头菌的魔法机)
  - [回文判断](#回文判断)
- 第五章
  - [幻方矩阵](#幻方矩阵)
  - [堆积木](#堆积木)
- 第六章
  - [神奇的二叉树](#神奇的二叉树)
  - [根据三元组数列建立二叉链表](#根据三元组数列建立二叉链表)
- 第七章
  - [互粉攻略](#互粉攻略)
  - [最短路简化版](#最短路简化版)
  - [修复公路](#修复公路) <span style="color:red">未通过</span>
- 第八章
  - [狗头菌筛选用户名](#狗头菌筛选用户名) <span style="color:yellow">超时</span>
  - [第一个没有出现的正数](#第一个没有出现的正数)
  - [两数之和](#两数之和)
- 第九章
  - [](#)
  - [](#)
## 第二章习题已在Apr. 30th关闭访问
## 第三章习题
### 通话记录  
[dialog.cpp](dialog.cpp)
已知 10 条通话记录，通话记录有三种类型：0 代表未接来电，1 代表已接来电，2 代表已拨电话。要求分别将三种类型前 10 条通话记录以三列的形式输出。  
**输入格式**  
输入 10 条通话记录，每条通话记录都占一行。每一行的第一个数字代表通话记录的类型，第二个数字代表电话号码，电话号码均由 11 个数字组成。他们之间用一个空格隔开。  
**输出格式**  
分三列输出未接来电、已接电话和已拨电话。每列之间用一个空格分割，最后一列后没有空格。每种类型输出前十个电话，先出现的通话记录先输出，不足十个的用 0 占位。


### 狗头菌的魔法机  
[magic.cpp](magic.cpp)
狗头菌有一台神奇的魔法机，它能将输入的序列进行一系列复杂的变换，输出原序列的另一种排列方式。狗头菌十分好奇魔法机的工作原理，终于有一天他尝试着把魔法机拆开研究了。通过一系列复杂的演算，狗头菌终于发现了魔法机的工作原理：其实魔法机就是一个栈，根据栈先进后出的性质，每次一个数字进栈或将栈顶元素弹出，由此可以产生不同的出栈序列，出栈序列就是原序列的另一种排列了。在研究完原理后，狗头菌凭借记忆很快就把魔法机组装好了。现在狗头菌想测试下魔法机在组装完成后是否出现问题。首先他将 1 到 N 这 N 个数字依次输入魔法机里，然后随机写下一组序列a，现在他想知道能否通过魔法机得到序列a，聪明的你能帮狗头菌算一算吗？  
**输入格式**  
输入有两行，第一行是一个正整数 N ($1 \leq N \leq 100$)，表示输入魔法机序列的长度，第二行是序列a，共有 N 个整数，表示要得到的目标序列。序列为 1 到 N 的排列，即序列a长度为 N，保证序列中的整数都不相同，且整数在区间 [1, N] 内。  
**输出格式**  
输出一行，如果能通过魔法机得到序列a，则输出YES，否则输出NO。

### 回文判断   
[palindrome.cpp](palindrome.cpp)
我们把正读和反读都相同的字符序列称为“回文”，例如abba和abcba是回文，abcde不是回文。尝试写一个算法判别读入的一个以@为结束符的字符是否是回文。  
**输入格式**  
输入为一行，为待判断的字符串，以@结尾。字符串长度不超过 20，除最后一个字符外，其余字符均由小写字母组成。  
**输出格式**  
输出一行，如果输入的字符串是回文，则输出true；如果输入的字符串不是回文，则输出false。

## 第五章习题
### 幻方矩阵
[matrix.cpp](matrix.cpp)
一天狗头菌买了一个幻方矩阵，这个矩阵每次可以交换任意两行或者任意两列。花椰妹看到说这么简单的东西，我自己就可以编程实现了。狗头菌要强地说这么简单我肯定也会，但是狗头菌并不会，只好求助你来编程实现。  
**输入格式**  
第一行输入两个整数 n,m，表示这个幻方矩阵大小为 $n \times m$。接下来是一个$n \times m$ 的矩阵。接下来一行有一个整数 op，表示有 op 次操作。接下来 op 行，每行有三个整数 x，y，z。当 x=0的时候表示交换第 y 行和第 z 行。当 x=1 的时候表示交换第 y 列和第 z 列。  
**输出格式**  
输出交换后的矩阵。数据范围对于 30% 的数据，$1 \le n, m, op \le 100$。对于 60% 的数据，$1 \le n, m, n \times m \le 10^5$，$1 \le op \le 100$。对于 100% 的数据，$1 \le n, m, n \times m,op \le 10^5$，$1 \le  矩阵中每个数字的大小  \le 10^6$。

### 堆积木
[toy.cpp](toy.cpp)
狗头菌有 n 块积木，编号分别为 1 到 n。一开始，狗头把第 i 块积木放在位置 i。狗头菌进行 m 次操作，每次操作，狗头把位置 b 上的积木整体移动到位置 a 上面。比如 1 位置的积木是 1，2 位置的积木是 2，那么把位置 2 的积木移动到位置 1 后，位置 1 上的积木从下到上依次为 1,2。  
**输入格式**  
第一行输入 2 个整数 $n,m\ (1 \le n \le 10000, 0 \le m \le 10000)$。接下来 m 行，每行输入 2 个整数 $a, b\ (1 \le a, b \le n)$，如果a，b 相等则本次不需要移动。  
**输出格式**  
输出 n 行，第 i 行输出位置 i 从下到上的积木编号，如果该行没有积木输出一行空行。


## 第六章习题
### 神奇的二叉树   
[binary.cpp](binary.cpp)
狗头菌最近在学习二叉树，可是心不在焉的他一会儿就学累了，于是他想休息会儿。狗头菌拿出镜子，对着镜子中的自己各种卖萌。狗头菌无意间看见镜子中出现了一棵二叉树，这不是他刚画的那棵二叉树么，在镜子里怎么左右颠倒了呀。狗头菌觉得好神奇，于是他又随手画了一棵二叉树，他想知道这棵二叉树在镜子里是长什么样的。为了将问题简单，现在狗头菌告诉你这棵二叉树的先序遍历结果和中序遍历结果，求原始二叉树的后序遍历结果，以及镜子里的二叉树的后序遍历结果。  
**输入格式**  
输入第一行是一个字符串pre_str，代表原始二叉树的先序遍历结果；输入第二行是一个字符串in_str，代表二叉树的中序遍历结果。每个字符代表结点的编号，结点的编号互不相同，字符仅由大小写字母组成。保证两个字符串长度相等，长度最大不超过 50，且保证可以通过先序遍历结果和中序遍历结果构造出一棵唯一的二叉树。  
**输出格式**  
输出第一行，输出一个字符串，代表原始二叉树的后序遍历结果；输出第二行，输出一个字符串，代表镜子里的二叉树的后序遍历结果。

### 根据三元组数列建立二叉链表
[triad.cpp](triad.cpp)
假设以三元组(F,C,L/R)的形式输入一棵二叉树的诸边（其中F表示双亲结点的标识，C标识孩子结点的标识，L/R标识C为F的左孩子或右孩子），且在输入的三元组序列中，C是按层次顺序出现的。设结点的标识是字符类型。F=^时C为根节点标识，若C也为^，则标识输入结束。试编写算法，由输入的三元组序列建立二叉树的二叉链表。  
**输入格式**  
输入为若干行，每行分别为三个字符，描述如题。  
**输出格式**  
输出共一行，为该二叉树的广义表达式。

## 第七章习题
### 互粉攻略
[fans.cpp](fans.cpp)
狗头菌和他的同事们最近在玩一个好玩的游戏：互粉攻略。一共有 N 个人参加游戏，编号从 0 到 N - 1，游戏前每个人都会展示自己最靓丽的一面。当游戏开始时，每个人可以选择去关注别人。当 A 关注了 B，则 A 就成了 B 的粉丝，但是并不意味着 B 同时关注了 A。当所有人都选好后，游戏结束，人气指数最高的人成为冠军。狗头菌制定了奇怪的规定：一个人的人气指数等于他的粉丝数减去关注数，因为狗头菌觉得人气高的人，往往有很多粉丝，并且一般都非常高冷，很少去关注别人。  
狗头菌发现一共有 M 条关注，粗心的他在统计时出了点小问题，所以可能会出现重复的关注。现在狗头菌想知道每个人的人气指数，聪明的你能帮帮他么？  
**输入格式**  
第一行输入两个数 n 和 m，$1\leq n\leq 1000$ ，$1 \leq m \leq 100000$。接下来输入 m 行，每行输入两个数 a 和 b，表示编号 a 的人关注了编号 b 的人，$0 \leq a, b \leq n - 1, a \neq b$。  
**输出格式**  
输出 N 行，每行输出每个人的人气指数，按编号依次输出即可。

### 最短路简化版
[road.cpp](road.cpp)
经历一周忙碌的工作后，狗头菌想趁着周末好好游玩一番。狗头菌想去好多好多地方，他想去南锣鼓巷吃各种好吃的，想去颐和园滑冰，还想去怀柔滑雪场滑雪……可是时间有限，狗头菌并不能玩遍所有的地方，最后他决定去几个离他较近的。  
我们知道狗头菌一共想去 N 个地方玩耍，编号从 1 到 N，并且知道了狗头菌所在地方的编号 C，以及 M 条路径。现在狗头菌想让你帮他算一算，他到每个地方分别需要经过多少个地方？  
**输入格式**  
第一行输入三个正整数 N, M, C。代表狗头菌想去 N 个地方，有 M 条路径，狗头菌在编号为 C 的地方。$1 \leq N, C \leq 1000$ , $1 \leq C \leq N$, $1 \leq M \leq 10000$。
保证没有重复边，且图中所有点互相连通。  
**输出格式**  
输出 NN 行，按编号从小到大，输出结果。第 ii 行表示狗头菌到编号为 ii 的地方，需要经过多少个地方。

### 修复公路
~~[renovation.cpp]()~~
某地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车，政府派若干个工程队同时修复这些公路。给出该地区的村庄数 N，和公路数 M，公路是双向的。并告诉你每条公路的连着哪两个村庄，什么时候能修完这条公路，问最早什么时候任意两个村庄能够通车。  
**输入格式**  
第一行两个正整数 $N,M\ (2 \le N \le 1000,1\le M \le 10^5)$，分别表示村庄的个数和公路数。  
下面 M 行，每行三个正整数 $x, y, t\ (1\le x,y \le n,1\le t \le 10^5)$，告诉你这条公路连着 x,y 两个村庄，在时间 t 时能修复完成这条公路。  
**输出格式**  
如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 −1，否则输出最早什么时候任意两个村庄能够通车。

## 第八章习题
### 狗头菌筛选用户名
[user.cpp](user.cpp)
某天，狗头菌发现公司上的用户名好多都长一样，狗头菌看着差点看晕了。为了区分用户名，狗头菌打算好好地清理清理。他将筛选出用户名一样的用户信息，然后给这些用户发邮件，提醒他们改一改用户名。需要注意的是，狗头菌不分大小写字母，所以他认为两个长度相等，每个字符对应一样的用户名是一样的，例如他认为用户名jiSHIke和JiSHIKe是一样的。  
现在狗头菌手里有 N 个用户名，他想知道哪些用户名是重复的。狗头菌按从前往后的顺序依次查看，如果用户名在前面出现过则输出Yes，否则输出No。现在狗头菌想请你帮他完成这项艰巨的任务，聪明的你能帮他完成吗？  
**输入格式**  
输入第一行是一个正整数 $N (1 \leq N \leq 100000)$，表示一共有 N 个用户名。接下来有 NN 行，每一行是一个用户名，长度不超过 100，均由大写字母和小写字母组成。  
**输出格式**  
请按照输入顺序输出，如果用户名在前面出现过则输出Yes，否则输出No，一行输出一个。  
**提示**  
可以参考之前课程的代码。  
建议将size设置为 200000 以上。

### 第一个没有出现的正数
[first.cpp](first.cpp)
给定一个具有 n 个元素的数组 A，请找出数组中第一个没出现的正数。
*例如：*
给定$[1,2,0]$，则返回 3。
给定$[3,4,-1,1]$，则返回 2。
*注意：*
算法需要 $\mathcal{O}(n)$ 的时间复杂度以及线性的空间复杂度。  
**输入格式**  
第一行输入整数 $n(n \leq10^6)$，接下来一行输入数组A[n]。  
**输出格式**  
输出第一个没出现的正数。


### 两数之和
[sum.cpp](sum.cpp)
给定一个数组 $number_i$
 ，找到两个数，使得他们的和为一个给定的数值 $target$。  
其中：$number[index_1] + number[index_2]==target$  
*注意：*$index_1$必须小于 $index_2$
且不能为 0。假设每一组输入只有唯一的一组解。
例如，对于数组 $[2,7,11,15]$ 和 $target=9$，$index_1$的值为 1，$index_2$的值为 2。  
**输入格式**  
第一行输入一个整数 $n(1 \leq n \leq 500)$，接下来的两行分别输入 n 个整数组成的数组 $number_i(0 \leq number_i \leq 1000)$和一个整数 $target(0 \leq target \leq 1000)$。  
**输出格式**  
输出一行由空格分隔的两个整数 index1 和 index2。注意，下标从 1 开始。