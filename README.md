# Data_Structure_of_USTB
a repository of work “数据结构”  
## 目录 content
- 第二章
- 第三章
  - [通话记录](#通话记录)
  - [蒜头君的魔法机](#蒜头君的魔法机)
  - [回文判断](#回文判断)
- 第五章
  - [幻方矩阵](#幻方矩阵)
  - [堆积木](#堆积木)
- 第六章
  - [神奇的二叉树](#神奇的二叉树)
  - [根据三元组数列建立二叉链表](#根据三元组数列建立二叉链表)
## 第二章习题已在Apr. 30th关闭访问
## 第三章习题
### 通话记录  
[dialog.cpp](dialog.cpp)
已知 10 条通话记录，通话记录有三种类型：0 代表未接来电，1 代表已接来电，2 代表已拨电话。要求分别将三种类型前 10 条通话记录以三列的形式输出。  
**输入格式**  
输入 10 条通话记录，每条通话记录都占一行。每一行的第一个数字代表通话记录的类型，第二个数字代表电话号码，电话号码均由 11 个数字组成。他们之间用一个空格隔开。  
**输出格式**  
分三列输出未接来电、已接电话和已拨电话。每列之间用一个空格分割，最后一列后没有空格。每种类型输出前十个电话，先出现的通话记录先输出，不足十个的用 0 占位。


### 蒜头君的魔法机  
[magic.cpp](magic.cpp)
蒜头君有一台神奇的魔法机，它能将输入的序列进行一系列复杂的变换，输出原序列的另一种排列方式。蒜头君十分好奇魔法机的工作原理，终于有一天他尝试着把魔法机拆开研究了。通过一系列复杂的演算，蒜头君终于发现了魔法机的工作原理：其实魔法机就是一个栈，根据栈先进后出的性质，每次一个数字进栈或将栈顶元素弹出，由此可以产生不同的出栈序列，出栈序列就是原序列的另一种排列了。在研究完原理后，蒜头君凭借记忆很快就把魔法机组装好了。现在蒜头君想测试下魔法机在组装完成后是否出现问题。首先他将 1 到 N 这 N 个数字依次输入魔法机里，然后随机写下一组序列a，现在他想知道能否通过魔法机得到序列a，聪明的你能帮蒜头君算一算吗？  
**输入格式**  
输入有两行，第一行是一个正整数 N ($1 \leq N \leq 100$)，表示输入魔法机序列的长度，第二行是序列a，共有 N 个整数，表示要得到的目标序列。序列为 1 到 N 的排列，即序列a长度为 N，保证序列中的整数都不相同，且整数在区间 [1, N] 内。  
**输出格式**  
输出一行，如果能通过魔法机得到序列a，则输出YES，否则输出NO。

### 回文判断   
[palindrome.cpp](palindrome.cpp)
我们把正读和反读都相同的字符序列称为“回文”，例如abba和abcba是回文，abcde不是回文。尝试写一个算法判别读入的一个以@为结束符的字符是否是回文。  
**输入格式**  
输入为一行，为待判断的字符串，以@结尾。字符串长度不超过 20，除最后一个字符外，其余字符均由小写字母组成。  
**输出格式**  
输出一行，如果输入的字符串是回文，则输出true；如果输入的字符串不是回文，则输出false。

## 第五章习题
### 幻方矩阵
[matrix.cpp](matrix.cpp)
一天蒜头君买了一个幻方矩阵，这个矩阵每次可以交换任意两行或者任意两列。花椰妹看到说这么简单的东西，我自己就可以编程实现了。蒜头君要强地说这么简单我肯定也会，但是蒜头君并不会，只好求助你来编程实现。  
**输入格式**  
第一行输入两个整数 n,m，表示这个幻方矩阵大小为 $n \times m$。接下来是一个$n \times m$ 的矩阵。接下来一行有一个整数 op，表示有 op 次操作。接下来 op 行，每行有三个整数 x，y，z。当 x=0的时候表示交换第 y 行和第 z 行。当 x=1 的时候表示交换第 y 列和第 z 列。  
**输出格式**  
输出交换后的矩阵。数据范围对于 30% 的数据，$1 \le n, m, op \le 100$。对于 60% 的数据，$1 \le n, m, n \times m \le 10^5$，$1 \le op \le 100$。对于 100% 的数据，$1 \le n, m, n \times m,op \le 10^5$，$1 \le  矩阵中每个数字的大小  \le 10^6$。

### 堆积木
[toy.cpp](toy.cpp)
蒜头君有 n 块积木，编号分别为 1 到 n。一开始，蒜头把第 i 块积木放在位置 i。蒜头君进行 m 次操作，每次操作，蒜头把位置 b 上的积木整体移动到位置 a 上面。比如 1 位置的积木是 1，2 位置的积木是 2，那么把位置 2 的积木移动到位置 1 后，位置 1 上的积木从下到上依次为 1,2。  
**输入格式**  
第一行输入 2 个整数 $n,m\ (1 \le n \le 10000, 0 \le m \le 10000)$。接下来 m 行，每行输入 2 个整数 $a, b\ (1 \le a, b \le n)$，如果a，b 相等则本次不需要移动。  
**输出格式**  
输出 n 行，第 i 行输出位置 i 从下到上的积木编号，如果该行没有积木输出一行空行。


## 第六章习题
### 神奇的二叉树   
[binary.cpp](binary.cpp)
蒜头君最近在学习二叉树，可是心不在焉的他一会儿就学累了，于是他想休息会儿。蒜头君拿出镜子，对着镜子中的自己各种卖萌。蒜头君无意间看见镜子中出现了一棵二叉树，这不是他刚画的那棵二叉树么，在镜子里怎么左右颠倒了呀。蒜头君觉得好神奇，于是他又随手画了一棵二叉树，他想知道这棵二叉树在镜子里是长什么样的。为了将问题简单，现在蒜头君告诉你这棵二叉树的先序遍历结果和中序遍历结果，求原始二叉树的后序遍历结果，以及镜子里的二叉树的后序遍历结果。  
**输入格式**  
输入第一行是一个字符串pre_str，代表原始二叉树的先序遍历结果；输入第二行是一个字符串in_str，代表二叉树的中序遍历结果。每个字符代表结点的编号，结点的编号互不相同，字符仅由大小写字母组成。保证两个字符串长度相等，长度最大不超过 50，且保证可以通过先序遍历结果和中序遍历结果构造出一棵唯一的二叉树。  
**输出格式**  
输出第一行，输出一个字符串，代表原始二叉树的后序遍历结果；输出第二行，输出一个字符串，代表镜子里的二叉树的后序遍历结果。

### 根据三元组数列建立二叉链表
[triad.cpp](triad.cpp)
假设以三元组(F,C,L/R)的形式输入一棵二叉树的诸边（其中F表示双亲结点的标识，C标识孩子结点的标识，L/R标识C为F的左孩子或右孩子），且在输入的三元组序列中，C是按层次顺序出现的。设结点的标识是字符类型。F=^时C为根节点标识，若C也为^，则标识输入结束。试编写算法，由输入的三元组序列建立二叉树的二叉链表。  
**输入格式**  
输入为若干行，每行分别为三个字符，描述如题。  
**输出格式**  
输出共一行，为该二叉树的广义表达式。